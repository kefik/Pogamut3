
	 	/**
         IMPORTANT !!!

         DO NOT EDIT THIS FILE. IT IS GENERATED FROM approriate xml file in xmlresources/gbcommands BY
         THE JavaClassesGenerator.xslt. MODIFY THAT FILE INSTEAD OF THIS ONE.
         
         Use Ant task process-gb-messages after that to generate .java files again.
         
         IMPORTANT END !!!
        */
 	package cz.cuni.amis.pogamut.ut2004.communication.messages.gbcommands;import java.util.*;import javax.vecmath.*;import cz.cuni.amis.pogamut.base.communication.messages.*;import cz.cuni.amis.pogamut.base.communication.worldview.*;import cz.cuni.amis.pogamut.base.communication.worldview.event.*;import cz.cuni.amis.pogamut.base.communication.worldview.object.*;import cz.cuni.amis.pogamut.multi.communication.worldview.object.*;import cz.cuni.amis.pogamut.base.communication.translator.event.*;import cz.cuni.amis.pogamut.multi.communication.translator.event.*;import cz.cuni.amis.pogamut.base3d.worldview.object.*;import cz.cuni.amis.pogamut.base3d.worldview.object.event.*;import cz.cuni.amis.pogamut.ut2004.communication.messages.*;import cz.cuni.amis.pogamut.ut2004.communication.worldview.objects.*;import cz.cuni.amis.pogamut.ut2004multi.communication.worldview.objects.*;import cz.cuni.amis.pogamut.ut2004.communication.translator.itemdescriptor.*;import cz.cuni.amis.pogamut.ut2004.communication.messages.ItemType.Category;import cz.cuni.amis.pogamut.unreal.communication.messages.UnrealId;import cz.cuni.amis.utils.exception.*;import cz.cuni.amis.pogamut.base.communication.translator.event.IWorldObjectUpdateResult.Result;import cz.cuni.amis.utils.SafeEquals;import cz.cuni.amis.pogamut.base.agent.*;import cz.cuni.amis.pogamut.multi.agent.*;import cz.cuni.amis.pogamut.multi.communication.worldview.property.*;import cz.cuni.amis.pogamut.ut2004multi.communication.worldview.property.*;import cz.cuni.amis.utils.token.*;import cz.cuni.amis.utils.*;
 		/**
 		 * Representation of the GameBots2004 command DODGE.
 		 *
 		 * 
		Causes the bot to dodge to supported direction. Only one (successful) dodge per second allowed.
	
         */
 	public class Dodge 
		extends CommandMessage
	        {
	        	
		        
    	/** Example how the message looks like - used during parser tests. */
    	public static final String PROTOTYPE =
    		" {Direction 0,0,0}  {FocusPoint 0,0,0}  {Wall False}  {Double False} ";
    
		/**
		 * Creates new instance of command Dodge.
		 * 
		Causes the bot to dodge to supported direction. Only one (successful) dodge per second allowed.
	
		 * Corresponding GameBots message for this command is
		 * DODGE.
		 *
		 * 
		 *    @param Direction 
			Relative vector, will be normalized. The direction of the
			dodge will be added to current bot rotation.
		
		 *    @param FocusPoint 
			Point the bot should focus after dodge command. Note that if not specified, this will be set automatically by dodge command to 1200 ut units in front of the bot at the time when the dodge command is issued.
		
		 *    @param Wall 
			Attemtps to do a wall dodge. There has to be a wall in the opposite direction of the dodge. If there isn't, nothing will happen! This switch overrides "Double" dodge switch.
		
		 *    @param Double 
			If true performs a double dodge in specified direction.
		
		 */
		public Dodge(
			Location Direction,  Location FocusPoint,  Boolean Wall,  Boolean Double
		) {
			
				this.Direction = Direction;
            
				this.FocusPoint = FocusPoint;
            
				this.Wall = Wall;
            
				this.Double = Double;
            
		}

		
			/**
			 * Creates new instance of command Dodge.
			 * 
		Causes the bot to dodge to supported direction. Only one (successful) dodge per second allowed.
	
			 * Corresponding GameBots message for this command is
			 * DODGE.
			 * <p></p>
			 * WARNING: this is empty-command constructor, you have to use setters to fill it up with data that should be sent to GameBots2004!
		     */
		    public Dodge() {
		    }
			
		
		/**
		 * Cloning constructor.
		 *
		 * @param original
		 */
		public Dodge(Dodge original) {
		   
		        this.Direction = original.Direction;
		   
		        this.FocusPoint = original.FocusPoint;
		   
		        this.Wall = original.Wall;
		   
		        this.Double = original.Double;
		   
		}
    
	        /**
	        
			Relative vector, will be normalized. The direction of the
			dodge will be added to current bot rotation.
		 
	        */
	        protected
	         Location Direction =
	       	
	        		null
	        	;
	
	        
	        
 		/**
         * 
			Relative vector, will be normalized. The direction of the
			dodge will be added to current bot rotation.
		 
         */
        public Location getDirection()
 	
	        {
	            return
	        	 Direction;
	        }
	        
	        
	        
 		
 		/**
         * 
			Relative vector, will be normalized. The direction of the
			dodge will be added to current bot rotation.
		 
         */
        public Dodge 
        setDirection(Location Direction)
 	
			{
				this.Direction = Direction;
				return this;
			}
		
	        /**
	        
			Point the bot should focus after dodge command. Note that if not specified, this will be set automatically by dodge command to 1200 ut units in front of the bot at the time when the dodge command is issued.
		 
	        */
	        protected
	         Location FocusPoint =
	       	
	        		null
	        	;
	
	        
	        
 		/**
         * 
			Point the bot should focus after dodge command. Note that if not specified, this will be set automatically by dodge command to 1200 ut units in front of the bot at the time when the dodge command is issued.
		 
         */
        public Location getFocusPoint()
 	
	        {
	            return
	        	 FocusPoint;
	        }
	        
	        
	        
 		
 		/**
         * 
			Point the bot should focus after dodge command. Note that if not specified, this will be set automatically by dodge command to 1200 ut units in front of the bot at the time when the dodge command is issued.
		 
         */
        public Dodge 
        setFocusPoint(Location FocusPoint)
 	
			{
				this.FocusPoint = FocusPoint;
				return this;
			}
		
	        /**
	        
			Attemtps to do a wall dodge. There has to be a wall in the opposite direction of the dodge. If there isn't, nothing will happen! This switch overrides "Double" dodge switch.
		 
	        */
	        protected
	         Boolean Wall =
	       	
	        		null
	        	;
	
	        
	        
 		/**
         * 
			Attemtps to do a wall dodge. There has to be a wall in the opposite direction of the dodge. If there isn't, nothing will happen! This switch overrides "Double" dodge switch.
		 
         */
        public Boolean isWall()
 	
	        {
	            return
	        	 Wall;
	        }
	        
	        
	        
 		
 		/**
         * 
			Attemtps to do a wall dodge. There has to be a wall in the opposite direction of the dodge. If there isn't, nothing will happen! This switch overrides "Double" dodge switch.
		 
         */
        public Dodge 
        setWall(Boolean Wall)
 	
			{
				this.Wall = Wall;
				return this;
			}
		
	        /**
	        
			If true performs a double dodge in specified direction.
		 
	        */
	        protected
	         Boolean Double =
	       	
	        		null
	        	;
	
	        
	        
 		/**
         * 
			If true performs a double dodge in specified direction.
		 
         */
        public Boolean isDouble()
 	
	        {
	            return
	        	 Double;
	        }
	        
	        
	        
 		
 		/**
         * 
			If true performs a double dodge in specified direction.
		 
         */
        public Dodge 
        setDouble(Boolean Double)
 	
			{
				this.Double = Double;
				return this;
			}
		
 	    public String toString() {
            return toMessage();
        }
 	
 		public String toHtmlString() {
			return super.toString() + "[<br/>" +
            	
            	"<b>Direction</b> = " +
            	String.valueOf(getDirection()
 	) +
            	" <br/> " +
            	
            	"<b>FocusPoint</b> = " +
            	String.valueOf(getFocusPoint()
 	) +
            	" <br/> " +
            	
            	"<b>Wall</b> = " +
            	String.valueOf(isWall()
 	) +
            	" <br/> " +
            	
            	"<b>Double</b> = " +
            	String.valueOf(isDouble()
 	) +
            	" <br/> " +
            	 
            	"<br/>]"
            ;
		}
 	
		public String toMessage() {
     		StringBuffer buf = new StringBuffer();
     		buf.append("DODGE");
     		
					    if (Direction != null) {
					        buf.append(" {Direction " +
					            Direction.getX() + "," +
					            Direction.getY() + "," +
					            Direction.getZ() + "}");
					    }
					
					    if (FocusPoint != null) {
					        buf.append(" {FocusPoint " +
					            FocusPoint.getX() + "," +
					            FocusPoint.getY() + "," +
					            FocusPoint.getZ() + "}");
					    }
					
						if (Wall != null) {
							buf.append(" {Wall " + Wall + "}");
						}
					
						if (Double != null) {
							buf.append(" {Double " + Double + "}");
						}
					
   			return buf.toString();
   		}
 	
 		// --- Extra Java from XML BEGIN (extra/code/java)
        	
		// --- Extra Java from XML END (extra/code/java)
 	
	        }
    	